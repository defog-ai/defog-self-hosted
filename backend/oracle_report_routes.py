import os
from typing import Optional

from fastapi import APIRouter
from fastapi.responses import JSONResponse
from pydantic import BaseModel
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.sql import select
from oracle.utils_report import summary_dict_to_markdown
from db_models import (
    OracleAnalyses,
    OracleReports,
)
from db_config import engine
from auth_utils import validate_user
from generic_utils import get_api_key_from_key_name
from oracle.constants import TaskStage

router = APIRouter()


class BasicRequest(BaseModel):
    """
    Basic request model for identifying the user and the api key.
    """

    key_name: str
    token: str

    model_config = {
        "json_schema_extra": {
            "examples": [{"key_name": "my_api_key", "token": "my_token"}]
        }
    }


class ReportRequest(BasicRequest):
    """
    Request model for identifying the report to be accessed / modified.
    """

    report_id: int

    model_config = {
        "json_schema_extra": {"examples": [{"key_name": "my_api_key", "report_id": 1}]}
    }


class ReportAnalysisRequest(ReportRequest):
    """
    Request model for requesting a specific analysis of a report.
    """

    analysis_id: str

    model_config = {
        "json_schema_extra": {
            "examples": [{"key_name": "my_api_key", "report_id": 1, "analysis_id": 1}]
        }
    }


@router.post("/oracle/list_reports")
async def reports_list(req: BasicRequest):
    """
    Get the list of reports that have been generated by the user, including
    those in progress. Returns a list of dictionaries, each containing:
    - report_id
    - report_name
    - status
    - date_created
    """
    if not (await validate_user(req.token)):
        return JSONResponse(status_code=401, content={"error": "Unauthorized"})
    api_key = await get_api_key_from_key_name(req.key_name)

    async with AsyncSession(engine) as session:
        async with session.begin():
            stmt = (
                select(
                    OracleReports.report_id,
                    OracleReports.report_name,
                    OracleReports.status,
                    OracleReports.created_ts,
                    OracleReports.inputs,
                )
                .where(OracleReports.db_name == api_key)
                .order_by(OracleReports.created_ts.desc())
            )
            result = await session.execute(stmt)
            reports = result.fetchall()

    reports_list = []
    for report in reports:
        status = report.status or ""
        is_revision = status.startswith("Revision: ")
        is_being_revised = status.startswith("Revision in progress: ")
        if is_revision:
            continue
        reports_list.append(
            {
                "report_id": report.report_id,
                "report_name": report.report_name,
                "status": report.status,
                "is_revision": is_revision,
                "is_being_revised": is_being_revised,
                "date_created": report.created_ts.isoformat(),  # Convert to ISO 8601 string
                "inputs": report.inputs,
            }
        )

    return JSONResponse(status_code=200, content={"reports": reports_list})


@router.post("/oracle/delete_report")
async def delete_report(req: ReportRequest):
    """
    Given a report_id, this endpoint will delete the report from the system.
    Reports in progress will have their associated background tasks cancelled.
    """
    if not (await validate_user(req.token)):
        return JSONResponse(status_code=401, content={"error": "Unauthorized"})
    api_key = await get_api_key_from_key_name(req.key_name)
    report = None

    async with AsyncSession(engine) as session:
        async with session.begin():
            stmt = select(OracleReports).where(
                OracleReports.db_name == api_key,
                OracleReports.report_id == req.report_id,
            )
            result = await session.execute(stmt)
            report = result.scalar_one_or_none()
            if report:
                await session.delete(report)

    if report:
        return JSONResponse(status_code=200, content={"message": "Report deleted"})
    else:
        return JSONResponse(status_code=404, content={"error": "Report not found"})


@router.post("/oracle/get_report_mdx")
async def get_report_mdx(req: ReportRequest):
    """
    Given a report_id, this endpoint will return the MDX string for the report stored in the postgres db.

    Will return status 400 if no string is found.
    """
    if not (await validate_user(req.token)):
        return JSONResponse(status_code=401, content={"error": "Unauthorized"})
    api_key = await get_api_key_from_key_name(req.key_name)

    async with AsyncSession(engine) as session:
        async with session.begin():
            stmt = select(OracleReports).where(
                OracleReports.db_name == api_key,
                OracleReports.report_id == req.report_id,
            )
            result = await session.execute(stmt)
            report = result.scalar_one_or_none()

            if report:
                mdx = report.outputs.get(TaskStage.EXPORT.value, {}).get("mdx", "")
                md = report.outputs.get(TaskStage.EXPORT.value, {}).get("md", "")
                tiptap_mdx = report.outputs.get(TaskStage.EXPORT.value, {}).get(
                    "tiptap_mdx", ""
                )

                summary_dict = report.outputs.get(TaskStage.EXPORT.value, {}).get(
                    "executive_summary", None
                )

                if not summary_dict:
                    return JSONResponse(
                        status_code=400,
                        content={
                            "error": "Bad Request",
                            "message": "No summary dict found for report",
                        },
                    )

                if not mdx:
                    _, summary_mdx = summary_dict_to_markdown(summary_dict)
                    mdx = summary_mdx.strip()

                if not tiptap_mdx:
                    _, summary_mdx = summary_dict_to_markdown(
                        summary_dict, wrap_in_tags=True
                    )
                    tiptap_mdx = summary_mdx.strip()

                return JSONResponse(
                    status_code=200,
                    content={
                        "mdx": mdx,
                        "md": md,
                        "tiptap_mdx": tiptap_mdx,
                    },
                )
            else:
                return JSONResponse(
                    status_code=404,
                    content={"error": "Report not found"},
                )


class UpdateReportMDXRequest(ReportRequest):
    """
    Request model for updating the MDX string for a report. This will allow us to update both the initially generated mdx and the tiptap's edited mdx.

    We separate the two because we want to keep the original mdx for exporting/revision purposes later on.
    """

    mdx: Optional[str] = None
    tiptap_mdx: Optional[str] = None

    model_config = {
        "json_schema_extra": {
            "examples": [
                {"key_name": "my_api_key", "report_id": 1, "mdx": "MDX string"}
            ]
        }
    }


@router.post("/oracle/get_report_analysis_ids")
async def get_report_analysis_ids(req: ReportRequest):
    """
    Given a report_id, this endpoint will return the list of analyses ids for the report.
    """
    if not (await validate_user(req.token)):
        return JSONResponse(status_code=401, content={"error": "Unauthorized"})
    api_key = await get_api_key_from_key_name(req.key_name)

    async with AsyncSession(engine) as session:
        async with session.begin():
            stmt = select(OracleAnalyses).where(
                OracleAnalyses.db_name == api_key,
                OracleAnalyses.report_id == req.report_id,
            )
            result = await session.execute(stmt)
            result = result.scalars().all()
            analyses = [row.analysis_id for row in result]

            return JSONResponse(status_code=200, content={"analyses": analyses})


@router.post("/oracle/get_report_analysis")
async def get_report_analysis(req: ReportAnalysisRequest):
    """
    Given a report_id and an analysis_id, this endpoint will return the analysis for the report.
    """
    if not (await validate_user(req.token)):
        return JSONResponse(status_code=401, content={"error": "Unauthorized"})
    api_key = await get_api_key_from_key_name(req.key_name)

    # get the report
    async with AsyncSession(engine) as session:
        async with session.begin():
            stmt = select(OracleAnalyses).where(
                OracleAnalyses.db_name == api_key,
                OracleAnalyses.report_id == req.report_id,
                OracleAnalyses.analysis_id == req.analysis_id,
            )
            result = await session.execute(stmt)
            row = result.scalar_one_or_none()
            if row:
                analysis = {
                    column.name: getattr(row, column.name)
                    for column in OracleAnalyses.__table__.columns
                }
                return JSONResponse(
                    status_code=200,
                    content=analysis,
                )
            return JSONResponse(
                status_code=404, content={"error": "Analysis not found"}
            )


@router.post("/oracle/get_report_status")
async def get_report_status(req: ReportRequest):
    """
    Given a report_id, this endpoint will return the status of the report.
    """
    if not (await validate_user(req.token)):
        return JSONResponse(status_code=401, content={"error": "Unauthorized"})
    api_key = await get_api_key_from_key_name(req.key_name)

    # get the report
    async with AsyncSession(engine) as session:
        async with session.begin():
            stmt = select(OracleReports).where(
                OracleReports.db_name == api_key,
                OracleReports.report_id == req.report_id,
            )
            result = await session.execute(stmt)
            row = result.scalar_one_or_none()
            if row:
                return JSONResponse(
                    status_code=200,
                    content={"status": row.status},
                )
            return JSONResponse(status_code=404, content={"error": "Report not found"})


@router.post("/oracle/get_report_summary")
async def get_report_summary(req: ReportRequest):
    """
    Given a report_id, this endpoint will return the executive summary of the report.
    The executive summary will have links to the relevant analyses should the user want to
    dive deeper into a particular answer/insight.
    """
    if not (await validate_user(req.token)):
        return JSONResponse(status_code=401, content={"error": "Unauthorized"})
    api_key = await get_api_key_from_key_name(req.key_name)
    # get from export key's executive_summary
    executive_summary = None
    async with AsyncSession(engine) as session:
        async with session.begin():
            stmt = select(OracleReports.outputs).where(
                OracleReports.db_name == api_key,
                OracleReports.report_id == req.report_id,
            )
            result = await session.execute(stmt)
            outputs = result.scalar_one_or_none()
            executive_summary = outputs.get(TaskStage.EXPORT.value, {}).get(
                "executive_summary", None
            )
    if executive_summary:
        return JSONResponse(
            status_code=200, content={"executive_summary": executive_summary}
        )
    else:
        return JSONResponse(
            status_code=404,
            content={"error": "Executive summary not found"},
        )


@router.post("/oracle/get_report_comments")
async def get_report_comments(req: ReportRequest):
    """
    Given a report_id, this endpoint will return the comments for the report.
    """
    if not (await validate_user(req.token)):
        return JSONResponse(status_code=401, content={"error": "Unauthorized"})
    api_key = await get_api_key_from_key_name(req.key_name)

    async with AsyncSession(engine) as session:
        async with session.begin():
            stmt = select(OracleReports).where(
                OracleReports.db_name == api_key,
                OracleReports.report_id == req.report_id,
            )
            result = await session.execute(stmt)
            report = result.scalar_one_or_none()
            if report:
                return JSONResponse(
                    status_code=200, content={"comments": report.comments}
                )
            else:
                return JSONResponse(
                    status_code=404,
                    content={"error": "Report not found"},
                )


class UpdateReportCommentsRequest(ReportRequest):
    """
    Request model for updating the comments for a report.
    """

    comments: list

    model_config = {
        "json_schema_extra": {
            "examples": [
                {"key_name": "my_api_key", "report_id": 1, "comments": "Comments"}
            ]
        }
    }


@router.post("/oracle/update_report_comments")
async def update_report_comments(req: UpdateReportCommentsRequest):
    """
    Given a report_id, this endpoint will update the comments for the report.
    """
    if not (await validate_user(req.token)):
        return JSONResponse(status_code=401, content={"error": "Unauthorized"})
    api_key = await get_api_key_from_key_name(req.key_name)

    async with AsyncSession(engine) as session:
        async with session.begin():
            stmt = select(OracleReports).where(
                OracleReports.db_name == api_key,
                OracleReports.report_id == req.report_id,
            )
            result = await session.execute(stmt)
            report = result.scalar_one_or_none()

            if report:
                report.comments = req.comments
                return JSONResponse(
                    status_code=200, content={"message": "Comments updated"}
                )
            else:
                return JSONResponse(
                    status_code=404,
                    content={"error": "Report not found"},
                )
