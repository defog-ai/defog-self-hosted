from datetime import datetime
from fastapi import APIRouter, Request
from fastapi.responses import JSONResponse
from sqlalchemy.orm import Session
from sqlalchemy.sql import insert, select

from db_utils import OracleReports, engine, validate_user
from generic_utils import get_api_key_from_key_name
from oracle.core import begin_generation_task

router = APIRouter()

@router.post("/oracle/verify_objective")
async def verify_objective(req: Request):
    """
    Given the question / objective statement provided by the user, this endpoint
    will attempt to generate a query that can be used to derive the metric that
    the question is asking for. The query will be generated using defog-backend-python,
    run locally, and the results + SQL will be returned to the user for verification.
    """
    body = await req.json()
    # TODO: Implement this endpoint
    return JSONResponse(status_code=501, content={"error": "Not Implemented"})

@router.post("/oracle/begin_generation")
async def begin_generation(req: Request):
    """
    Given the question / objective statement provided by the user, as well as the
    full list of configuration options, this endpoint will begin the process of
    generating a report asynchronously as a celery task.
    """
    body = await req.json()
    key_name = body.pop("key_name")
    token = body.pop("token")
    username = validate_user(token, user_type=None, get_username=True)
    if not username:
        return JSONResponse(
            status_code=401,
            content={
                "error": "unauthorized",
                "message": "Invalid username or password",
            },
        )
    api_key = get_api_key_from_key_name(key_name)
    # insert a new row into the OracleReports table and get a new report_id
    with Session(engine) as session:
        stmt = (
            insert(OracleReports)
            .values(
                api_key=api_key,
                username=username,
                inputs=body,
                status="started",
                created_ts=datetime.now()
            )
            .returning(OracleReports.report_id)
        )
        result = session.execute(stmt)
        report_id = result.scalar_one()
        session.commit()
    begin_generation_task.apply_async(args=[api_key, username, report_id, body])
    return JSONResponse(content={"report_id": report_id, "status": "started"})

@router.post("/oracle/list_reports")
async def reports_list(req: Request):
    """
    Get the list of reports that have been generated by the user, including
    those in progress. Returns a list of dictionaries, each containing:
    - report_id
    - report_name
    - status
    - date_created
    - feedback
    """
    body = await req.json()
    key_name = body.pop("key_name")
    token = body.pop("token")
    username = validate_user(token, user_type=None, get_username=True)
    if not username:
        return JSONResponse(
            status_code=401,
            content={
                "error": "unauthorized",
                "message": "Invalid username or password",
            },
        )
    api_key = get_api_key_from_key_name(key_name)

    with Session(engine) as session:
        stmt = (
            select(
                OracleReports.report_id,
                OracleReports.report_name,
                OracleReports.status,
                OracleReports.created_ts,
                OracleReports.inputs
            )
            .where(
                OracleReports.api_key == api_key,
                OracleReports.username == username
            )
            .order_by(OracleReports.created_ts.desc())
        )
        result = session.execute(stmt)
        reports = result.fetchall()

    reports_list = [
        {
            "report_id": report.report_id,
            "report_name": report.report_name,
            "status": report.status,
            "date_created": report.created_ts.isoformat(),  # Convert to ISO 8601 string
            "inputs": report.inputs,
        }
        for report in reports
    ]
    return JSONResponse(status_code=200, content={"reports": reports_list})

@router.post("/oracle/download_report")
async def download_report(req: Request):
    """
    Given a report_id, this endpoint will return the report pdf file to the user.
    """
    body = await req.json()
    # TODO: Implement this endpoint
    return JSONResponse(status_code=501, content={"error": "Not Implemented"})

@router.post("/oracle/delete_report")
async def delete_report(req: Request):
    """
    Given a report_id, this endpoint will delete the report from the system.
    Reports in progress will have their associated background tasks cancelled.
    """
    body = await req.json()
    key_name = body.pop("key_name", "")
    token = body.pop("token", "")
    report_id = body.pop("report_id", None)
    username = validate_user(token, user_type=None, get_username=True)
    if not username:
        return JSONResponse(
            status_code=401,
            content={
                "error": "unauthorized",
                "message": "Invalid username or password",
            },
        )
    api_key = get_api_key_from_key_name(key_name)

    with Session(engine) as session:
        stmt = (
            select(OracleReports)
            .where(
                OracleReports.api_key == api_key,
                OracleReports.username == username,
                OracleReports.report_id == report_id
            )
        )
        result = session.execute(stmt)
        report = result.scalar_one_or_none()
        if report:
            session.delete(report)
            session.commit()
            return JSONResponse(status_code=200, content={"message": "Report deleted"})
        else:
            return JSONResponse(status_code=404, content={"error": "Report not found"})

@router.post("/oracle/rename_report")
async def rename_report(req: Request):
    """
    Given a report_id and a new report_name, this endpoint will rename the report,
    and re-export the pdf with the new name in the title.
    """
    body = await req.json()
    # TODO: Implement this endpoint
    return JSONResponse(status_code=501, content={"error": "Not Implemented"})

@router.post("/oracle/feedback_report")
async def feedback_report(req: Request):
    """
    Given a report id and the associated feedback, save the feedback with the report.
    """
    body = await req.json()
    # TODO: Implement this endpoint
    return JSONResponse(status_code=501, content={"error": "Not Implemented"})

@router.post("/oracle/get_clarifications")
async def get_clarifications(req: Request):
    """
    This endpoint will return a list of clarifications that have
    been flagged by the oracle so far and have not been addressed.
    This will be a list of dictionaries, each containing:
    - report_id
    - user_question
    - clarification_question
    """
    body = await req.json()
    # TODO: Implement this endpoint
    return JSONResponse(status_code=501, content={"error": "Not Implemented"})

@router.post("/oracle/clarify_report")
async def clarify_report(req: Request):
    """
    This endpoint receives the clarification response from the user.
    If it is empty, the clarification is assumed to be dismissed / resolved and
    we save that information.
    If it is not empty, we will update the associated clarification question's
    response and continue the generation process if no clarifications are left
    unaddressed.
    """
    body = await req.json()
    # TODO: Implement this endpoint
    return JSONResponse(status_code=501, content={"error": "Not Implemented"})
