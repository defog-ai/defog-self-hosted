// this "analysis agent" will contain a similar view to the agent for report creation.
// just without the report display.
// we will reuse the code and endpoints of the report to generate "Sections" instead of full reports.
// when we finally get the report sections/text, we will add them to the content array of the block in the blocknote editor.
// The text generated by the model will only be useful on the initial render.
// Any edits after that will be stored in blocknote's editor state.
// of course, all of the content will be emptied out if the text of this "block/section/sections" is regenerated.

import { Popover, message } from "antd";
import React, {
  useEffect,
  useRef,
  useState,
  Fragment,
  useContext,
  useCallback,
} from "react";
import AnalysisGen from "./analysis-gen/AnalysisGen";
import { ThemeContext, lightThemeColor } from "../../context/ThemeContext";
import AgentLoader from "../common/AgentLoader";
import Lottie from "lottie-react";
import LoadingLottie from "../svg/loader.json";
import { DocContext, RelatedAnalysesContext } from "../../../docs/DocContext";
// import { customMarkdownToBlocks } from "../../../docs/customBlocks/customMarkdownParse"
import { PlusCircleOutlined, SettingOutlined } from "@ant-design/icons";
import { ToolResults } from "./ToolResults";
import StepsDag from "../common/StepsDag";
import ErrorBoundary from "../common/ErrorBoundary";
import { v4 } from "uuid";
import { Context } from "../../../../components/common/Context";
import { createAnalysis, getAnalysis } from "../../../../utils/utils";
import setupBaseUrl from  "../../../../utils/setupBaseUrl";
import { setupWebsocketManager } from "../../../../utils/websocket-manager";

// the name of the prop where the data is stored for each stage
const propNames = {
  clarify: "clarification_questions",
  gen_approaches: "approaches",
  gen_steps: "steps",
  gen_report: "report_sections",
};

const agentRequestTypes = ["clarify", "gen_steps"];

export const AnalysisAgent = ({
  analysisId,
  apiToken,
  updateHook = () => {},
  editor,
}) => {
  const [socketManager, setSocketManager] = useState(null);
  const [reRunManager, setReRunManager] = useState(null);
  const [toolSocketManager, setToolSocketManager] = useState(null);
  const [analysisData, setAnalysisData] = useState(null);
  const [analysisBusy, setAnalysisBusy] = useState(false);
  const [analysisSteps, setAnalysisSteps] = useState([]);
  const [relatedAnalyses, setRelatedAnalyses] = useState([]);
  const [recipeShowing, setRecipeShowing] = useState(false);
  const [pendingToolRunUpdates, setPendingToolRunUpdates] = useState({});
  const [reRunningSteps, setRerunningSteps] = useState([]);
  const relatedAnalysesContext = useContext(RelatedAnalysesContext);

  const [analysisTitle, setAnalysisTitle] = useState(
    analysisData?.user_question?.toUpperCase()
  );
  const [context, setContext] = useContext(Context);
  const { user } = context;
  const [activeNode, setActiveNodePrivate] = useState(null);
  const [dag, setDag] = useState(null);
  const [dagLinks, setDagLinks] = useState([]);

  const [toolRunDataCache, setToolRunDataCache] = useState({});

  function setActiveNode(node) {
    setActiveNodePrivate(node);
    // if update_prop is "sql" or "code_str" or "analysis", update tool_run_details
    // if update_prop is inputs, update step.inputs
    // update in context
    Object.keys(pendingToolRunUpdates).forEach((toolRunId) => {
      const updateProps = Object.keys(pendingToolRunUpdates[toolRunId]);
      const toolRunData = toolRunDataCache[toolRunId]?.tool_run_data;
      if (!toolRunData) return;

      updateProps.forEach((updateProp) => {
        if (updateProp === "sql" || updateProp === "code_str") {
          // update tool_run_details
          toolRunData.tool_run_details[updateProp] =
            pendingToolRunUpdates[toolRunId][updateProp];
        } else if (updateProp === "inputs") {
          // update step.inputs
          toolRunData.step.inputs =
            pendingToolRunUpdates[toolRunId][updateProp];
        }
      });
      toolRunData.edited = true;

      // update the cache
      setToolRunDataCache((prev) => {
        return {
          ...prev,
          [toolRunId]: {
            ...prev[toolRunId],
            tool_run_data: toolRunData,
          },
        };
      });
    });

    setPendingToolRunUpdates({});
  }

  useEffect(() => {
    if (analysisData?.gen_steps?.success && analysisData?.gen_steps?.steps) {
      setAnalysisSteps(
        analysisData.gen_steps.steps.slice().map((d) => {
          d.id = v4().slice(0, 8) + "-" + d["tool_name"];
          return d;
        })
      );
    }
  }, [analysisData]);

  useEffect(() => {
    if (!analysisData || !analysisId) return;

    relatedAnalysesContext.update({
      ...relatedAnalysesContext.val,
      [analysisId]: relatedAnalyses,
    });
  }, [relatedAnalyses]);

  const [currentStage, setCurrentStage] = useState(null);
  const [stageDone, setStageDone] = useState(true);
  const searchRef = useRef(null);
  const docContext = useContext(DocContext);

  function onMessage(event) {
    if (!event.data) {
      setStageDone(true);
      setAnalysisBusy(false);
      message.error(
        "Something went wrong. Please try again or contact us if this persists."
      );
    }

    const response = JSON.parse(event.data);

    console.log(response);

    if (response.error_message) {
      setStageDone(true);
      setAnalysisBusy(false);
      message.error(response.error_message);

      // revert the next stage to the previous one
      setCurrentStage((prev) => {
        const idx = agentRequestTypes.indexOf(prev);
        if (idx > 0) {
          return agentRequestTypes[idx - 1];
        } else {
          return null;
        }
      });
      return;
    }

    const rType = response.request_type;
    const prop = propNames[rType];

    if (
      response.output &&
      response.output.success &&
      response.output[prop] &&
      response.output[prop].length > 0
    ) {
      if (rType === "gen_report") {
        // run the hook
        // a use case for this hook:
        // if current stage is gen_report, we're expecting report sections
        // keep inserting as we receive them
        updateHook(
          response.output?.report_sections?.length &&
            response.output?.report_sections
        );
      }

      setAnalysisData((prev) => {
        // if the stage doesn't exist, just set
        if (!prev[rType]) {
          return { ...prev, [rType]: response.output };
        }

        let newAnalysisData = { ...prev };

        response.output[prop].forEach((res) => {
          // we can either append to the stage's current data
          // or merge to something based on a merge_key
          // fheck if the response has a merge_key
          let idx = -1;
          if (res.merge && res.merge_key) {
            // find the element in the stage's data that has the same merge_key
            // if it exists, update it
            // else append
            idx = newAnalysisData[rType][prop]?.findIndex(
              (d) => d[res.merge_key] === res[res.merge_key]
            );
          }

          if (idx > -1) {
            // update
            newAnalysisData[rType][prop][idx] = {
              ...newAnalysisData[rType][prop][idx],
              ...res,
            };
          } else {
            // append
            newAnalysisData[rType][prop].push(res);
          }
        });

        return newAnalysisData;
      });
    }
    if (response.done) {
      setStageDone(true);
      setAnalysisBusy(false);
    }
  }

  async function onReRunMessage(event) {
    const res = JSON.parse(event.data);
    // remove the tool run id from rerunning steps
    setRerunningSteps((prev) => prev.filter((d) => d !== res.tool_run_id));

    if (!res.success) {
      message.error(
        `Something went wrong while re running ${res.tool_run_id}. Please try again.`
      );
      message.error(res.error_message);
    }

    if (res.success) {
      setToolRunDataCache((prev) => {
        return {
          ...prev,
          [res.tool_run_id]: Object.assign({}, res),
        };
      });
      // remove all pending updates for this tool_run_id
      // because all new data is already there in the received response
      setPendingToolRunUpdates((prev) => {
        const newUpdates = { ...prev };
        delete newUpdates[res.tool_run_id];
        return newUpdates;
      });
    }

    // if this re run has an error_message (or if it doesn't), update the analysisSteps
    setAnalysisSteps((prev) => {
      const newSteps = prev.slice();
      const idx = newSteps.findIndex((d) => d.tool_run_id === res.tool_run_id);
      if (idx > -1) {
        newSteps[idx] = {
          ...newSteps[idx],
          error_message: res.error_message,
        };
      }
      return newSteps;
    });
  }

  useEffect(() => {
    function closeAnalysisOnClickOutside(e) {
      // only close if this wasn't the analysis title or the recipe itself
      if (
        !e.target.closest(".analysis-title") &&
        !e.target.closest(".analysis-recipe")
      )
        recipeShowing && setRecipeShowing(false);
    }

    document.addEventListener("click", closeAnalysisOnClickOutside);

    return () => {
      document.removeEventListener("click", closeAnalysisOnClickOutside);
    };
  }, [recipeShowing]);

  useEffect(() => {
    async function setupSocket() {
      const urlToConnect = setupBaseUrl("ws", "ws");
      try {
        const mgr = await setupWebsocketManager(urlToConnect, onMessage);
        setSocketManager(mgr);

        const rerunMgr = await setupWebsocketManager(
          urlToConnect.replace("/ws", "/step_rerun"),
          onReRunMessage
        );

        setReRunManager(rerunMgr);

        // get report data
        let analysisData = null;
        const res = await getAnalysis(analysisId);
        if (!res.success) {
          // create a new analysis
          analysisData = (await createAnalysis(apiToken, analysisId))
            .report_data;

          // also have to set docContext in this case
          docContext.update({
            ...docContext.val,
            userItems: {
              ...docContext.val.userItems,
              analyses: [...docContext.val.userItems.analyses, analysisData],
            },
          });
        } else {
          analysisData = res.report_data;
          const lastExistingStage = Object.keys(analysisData)
            .filter((d) => agentRequestTypes.includes(d))
            .sort(
              (a, b) =>
                agentRequestTypes.indexOf(a) - agentRequestTypes.indexOf(b)
            )
            .pop();
          setCurrentStage(lastExistingStage);
        }
        setAnalysisData(analysisData);
        setAnalysisTitle(analysisData?.user_question?.toUpperCase());
        setRelatedAnalyses({
          follow_up_analyses: analysisData?.follow_up_analyses || [],
          parent_analyses: analysisData?.parent_analyses || [],
        });

        const toolSocketManager = await setupWebsocketManager(
          urlToConnect.replace("/ws", "/edit_tool_run"),
          (d) => console.log(d)
        );
        setToolSocketManager(toolSocketManager);
      } catch (e) {
        console.log(e);
      }
    }
    setupSocket();

    return () => {
      if (socketManager && socketManager.close) {
        socketManager.close();
        // also stop the interval
        clearInterval(socketManager.interval);
      }
    };
  }, []);

  async function handleSubmit(ev, stageInput = {}, submitSourceStage = null) {
    try {
      if (!socketManager || !socketManager?.isConnected()) {
        message.error("Not connected to servers. Trying to reconnect.");
        message.error("Please contact us if this persists");
        return;
      }
      const query = searchRef.current.input.value;
      // if the submitSourceStage is "clarify", we're getting the user input for the clarification questions, so the next thing the agent
      // has to do is "understand". so send the "understand" request_type to the agent.
      // if this is null, which is the first stage on the front end
      // then just submit the question to the agent. question string + "clarify" request_type
      // if we're just entering the question for the first time,
      // we need to send a "clarify" request. so let submitSOurceStage be null
      // indexOf returns -1 and -1 + 1 is 0 so we get "clarify" from the agentRequestTypes array
      const nextStage =
        agentRequestTypes[agentRequestTypes.indexOf(submitSourceStage) + 1];

      // if submitSourceStage is null, we're submitting the question for the first time
      // so set the user_question property in analysisData.report_data
      if (!submitSourceStage) {
        setAnalysisData((prev) => {
          return {
            ...prev,
            user_question: query,
          };
        });
      }

      const body = {
        ...stageInput,
        request_type: nextStage,
        report_id: analysisId,
        user_question: query,
        skip_intro: true,
        skip_conclusion: true,
        max_approaches: 1,
        skip_extra_approaches: true,
        skip_text_gen: true,
        user_email: user,
        db_creds: null,
      };

      if (docContext.val.dbCreds.hasCreds) {
        body.db_creds = {
          ...docContext.val.dbCreds,
          db_type: docContext.val.dbCreds.dbType,
        };
      }

      socketManager.send(body);

      setCurrentStage(nextStage);
      setStageDone(false);
      setAnalysisBusy(nextStage);
      let newAnalysisData = { ...analysisData, user_question: query };
      newAnalysisData[nextStage] = {
        [propNames[nextStage]]: [],
        success: true,
      };

      // if current stage is gen_steps, hide the recipe
      if (currentStage === "gen_steps") {
        setRecipeShowing(false);
      }

      setAnalysisTitle(query?.toUpperCase());

      // if any of the stages includeing and after nextStage exists
      // remove all data from those stages (to mimic what happens on the backend)
      let idx = agentRequestTypes.indexOf(nextStage) + 1;
      if (idx < agentRequestTypes.length) {
        while (idx < agentRequestTypes.length) {
          delete newAnalysisData[agentRequestTypes[idx]];
          idx++;
        }
      }
      // empty the next stage data
      // deleting a prop removes a tab
      newAnalysisData[nextStage][propNames[nextStage]] = [];
      setAnalysisData(newAnalysisData);

      return true;
    } catch (err) {
      console.log(err);
      setStageDone(false);
      setAnalysisBusy(false);
      message.error(
        "Something went wrong. Please try again or contact us if this persists."
      );
      console.log(err);
      return false;
    }
  }

  const handleReRun = useCallback(
    (toolRunId) => {
      if (
        !toolRunId ||
        !dag ||
        !analysisId ||
        !reRunManager ||
        !reRunManager.send ||
        !activeNode
      )
        return;

      if (!reRunManager.isConnected()) {
        message.error("Not connected to servers. Trying to reconnect.");
        message.error("Please contact us if this persists");
        return;
      }

      const desc = [...activeNode.descendants()]
        .filter((d) => d.data.isTool)
        .map((d) => d.data.meta.tool_run_id);
      const anc = [...activeNode.ancestors()]
        .filter((d) => d.data.isTool)
        .map((d) => d.data.meta.tool_run_id);

      setRerunningSteps(Array.from(new Set([...desc, ...anc])));

      if (reRunManager && reRunManager.send) {
        reRunManager.send({
          tool_run_id: toolRunId,
          analysis_id: analysisId,
        });
      }
    },
    [reRunManager, analysisId, activeNode, setRerunningSteps]
  );

  return (
    <ErrorBoundary>
      <div className="analysis-agent-container">
        {/* {analysisTitle.length ? ( */}
        <>
          {currentStage === "gen_steps" ? (
            <div
              className="analysis-title"
              onClick={() => {
                setRecipeShowing(!recipeShowing);
              }}
            >
              <div className="remake-analysis">
                <Popover content={<span>Remake analysis</span>}>
                  <SettingOutlined />
                </Popover>
              </div>
              {analysisTitle}
            </div>
          ) : (
            <></>
          )}
        </>
        {/* ) : (
        <></>
      )} */}
        <ThemeContext.Provider
          value={{ theme: { type: "light", config: lightThemeColor } }}
          key="1"
        >
          {!analysisData ? (
            <div className="analysis-data-loader">
              <AgentLoader
                message={"Setting up..."}
                lottie={<Lottie animationData={LoadingLottie} loop={true} />}
              />
            </div>
          ) : (
            <div className="analysis-ctr">
              {currentStage === "gen_steps" ? (
                <>
                  <div
                    className={
                      "analysis-recipe has-data " +
                      (recipeShowing ? "show" : "")
                    }
                  >
                    <div
                      className="analysis-recipe-background"
                      onClick={() => {
                        setRecipeShowing(false);
                      }}
                    ></div>
                    <AnalysisGen
                      analysisData={analysisData}
                      user_question={analysisData?.user_question}
                      stageDone={stageDone}
                      globalLoading={analysisBusy}
                      currentStage={currentStage}
                      handleSubmit={handleSubmit}
                      searchRef={searchRef}
                    />
                  </div>
                  <>
                    <div className="analysis-content">
                      <div className="analysis-results">
                        <ErrorBoundary>
                          {analysisSteps.length ? (
                            <ToolResults
                              analysisId={analysisId}
                              activeNode={activeNode}
                              analysisData={analysisData}
                              toolSocketManager={toolSocketManager}
                              dag={dag}
                              setActiveNode={setActiveNode}
                              handleReRun={handleReRun}
                              reRunningSteps={reRunningSteps}
                              setPendingToolRunUpdates={
                                setPendingToolRunUpdates
                              }
                              toolRunDataCache={toolRunDataCache}
                              setToolRunDataCache={setToolRunDataCache}
                            ></ToolResults>
                          ) : (
                            analysisBusy && (
                              <AgentLoader
                                message={"Running analysis..."}
                                lottie={
                                  <Lottie
                                    animationData={LoadingLottie}
                                    loop={true}
                                  />
                                }
                              />
                            )
                          )}
                        </ErrorBoundary>
                      </div>
                      <div className="analysis-steps">
                        <StepsDag
                          steps={analysisSteps}
                          nodeRadius={5}
                          setActiveNode={setActiveNode}
                          activeNode={activeNode}
                          stageDone={
                            currentStage === "gen_steps" ? stageDone : true
                          }
                          dag={dag}
                          setDag={setDag}
                          dagLinks={dagLinks}
                          setDagLinks={setDagLinks}
                        />
                      </div>
                    </div>
                    <div
                      className="start-follow-up"
                      onClick={async () => {
                        const newAnalysisId = "analysis-" + v4();

                        // if the current analysis has any parent analyses, add the current analysis id to the parent analyses
                        // else, create a new analysis with the current analysis id as the parent analysis
                        let parents = [];
                        if (analysisData?.parent_analyses?.length) {
                          parents = analysisData.parent_analyses.slice();
                        }

                        // I thought of pushing the analysisTitle as well, but it might change later so keep as is.
                        parents.push(analysisId);

                        const res = await createAnalysis(
                          apiToken,
                          newAnalysisId,
                          {
                            other_data: {
                              parent_analyses: parents,
                            },
                          }
                        );
                        if (!res.success) return;

                        // create a new analysis block with the id from res.report_data.report_id
                        const currentBlock =
                          editor.getTextCursorPosition().block;
                        editor.insertBlocks(
                          [
                            {
                              type: "analysis",
                              props: {
                                analysisId: res.report_data.report_id,
                              },
                            },
                          ],
                          currentBlock,
                          "after"
                        );
                        setRelatedAnalyses({
                          ...relatedAnalyses,
                          follow_up_analyses: [
                            ...relatedAnalyses.follow_up_analyses,
                            res.report_data.report_id,
                          ],
                        });
                      }}
                    >
                      <PlusCircleOutlined />
                      Start a new follow-up analysis
                    </div>
                  </>
                </>
              ) : (
                <>
                  <div className="analysis-recipe show">
                    <AnalysisGen
                      analysisData={analysisData}
                      user_question={analysisData?.user_question}
                      stageDone={stageDone}
                      globalLoading={analysisBusy}
                      currentStage={currentStage}
                      handleSubmit={handleSubmit}
                      searchRef={searchRef}
                    />
                  </div>
                </>
              )}
            </div>
          )}
        </ThemeContext.Provider>
      </div>
    </ErrorBoundary>
  );
};
